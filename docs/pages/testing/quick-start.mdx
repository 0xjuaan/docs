---
title: Testing Framework
---

# Testing Framework
## How to use it

Import `CoreSimulatorLib` as shown in the example, and call the `init()` function

Then, call `CoreSimulatorLib.nextBlock()` in your test to move to the next block and execute any queued CoreWriter actions.

Example:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {Test} from "forge-std/Test.sol";
import {CoreSimulatorLib} from "@hyper-evm-lib/test/simulation/CoreSimulatorLib.sol";

contract ExampleTest is Test {

    function setUp() public {
        vm.createSelectFork("https://rpc.hyperliquid.xyz/evm");

        // initialize the HyperCore simulator
        CoreSimulatorLib.init();
    }

    function test() public { 

        // Make any smart contract calls, 
        // all CoreWriter and token bridging actions will be queued

        ...

        // move to the next block, performing all queued CoreWriter and bridging actions
        CoreSimulatorLib.nextBlock();

        // Now, all precompiles calls will be 
        //updated to account for the above executed actions
    }
}

```

Alternatively, you could inherit [`BaseSimulatorTest`](https://github.com/hyperliquid-dev/hyper-evm-lib/blob/main/test/BaseSimulatorTest.sol) for your tests, which sets up the `CoreSimulatorLib` in it's `setUp()` function

### Test utility functions

- `setRevertOnFailure`: make queued CoreWriter actions revert on failure (defaults to false to mimic onchain behavior).
- `setMarkPx`: set a token's mark price or adjust by bps to test trading PnL.
- `setSpotPx`: set a spot market's price 
- `setVaultMultiplier`: scale vault equity to simulate profit/loss scenarios.

- `forceAccountActivation`: activate a Core account.
- `forceSpot`: set an account's spot balance for a token
- `forcePerpBalance`: set an account's withdrawable perp USD.
- `forceStaking`: set an account's staking balance.
- `forceDelegation`: set an account's delegation amount and locked until timestamp for a validator.
- `forceVaultEquity`: set an account's vault equity and lock timestamp for a vault


### How it works

`HyperCore` replicates HyperCore state and behaviour for tests. It holds all state (accounts, spot balances, perp positions and margin, staking, vault equity) and exposes read functions used by precompiles.

Precompile calls are handled by `PrecompileSim.sol`, which is etched at each precompile address. When a precompile is called, its fallback forwards the read into `HyperCore` via the matching `CoreView` function. `CoreView` functions check if the value is already initialized in local state and returns that; if not, it performs a live RPC read via `RealL1Read.sol` and returns the onchain value.

CoreWriter actions are handled through `CoreWriterSim.sol`. It stores all incoming CoreWriter calls in a queue. When `CoreSimulatorLib.nextBlock()` is called, it executes the queued actions by calling the relevant execute functions on `HyperCore` and applies their state changes. Before applying each write, CoreExecution runs initializers to initialise the relevant state by fetching current onchain values. Then, the local state is updated, and subsequent precompile reads will use the stored state.

