---
title: Testing Framework
---

# Testing Framework
## How to use it

Inherit `BaseSimulatorTest` in your tests. It handles the simulator setup, and provides common constants used in testing. 

Call `CoreSimulatorLib.nextBlock()` to move to the next block and execute any queued CoreWriter actions. See the example below:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {Test} from "forge-std/Test.sol";
import {CoreSimulatorLib} from "@hyper-evm-lib/test/simulation/CoreSimulatorLib.sol";

contract ExampleTest is Test {

    function setUp() public {
        vm.createSelectFork("https://rpc.hyperliquid.xyz/evm");

        // initialize the HyperCore simulator
        CoreSimulatorLib.init();
    }

    function test() public { 

        // Make any smart contract calls, 
        // all CoreWriter and token bridging actions will be queued

        ...

        // move to the next block, performing all queued CoreWriter and bridging actions
        CoreSimulatorLib.nextBlock();

        // Now, all precompiles calls will be 
        //updated to account for the above executed actions
    }
}

```


### Test utility functions

- `setRevertOnFailure`: make queued CoreWriter actions revert on failure (defaults to false to mimic onchain behavior).
- `setMarkPx`: set a token's mark price or adjust by bps to test trading PnL.
- `setSpotPx`: set a spot market's price 
- `setVaultMultiplier`: scale vault equity to simulate profit/loss scenarios.

- `forceAccountActivation`: activate a Core account.
- `forceSpot`: set an account's spot balance for a token
- `forcePerpBalance`: set an account's withdrawable perp USD.
- `forceStaking`: set an account's staking balance.
- `forceDelegation`: set an account's delegation amount and locked until timestamp for a validator.
- `forceVaultEquity`: set an account's vault equity and lock timestamp for a vault


### How it works

`HyperCore` is a contract that replicates HyperCore state and behaviour for tests. It inherits three contracts: `CoreState.sol`, which holds all state (accounts, spot balances, perp positions and margin, staking, vault equity); `CoreView.sol`, which exposes read functions used by precompiles; and `CoreExecution.sol`, which applies all writes such as token/native transfers, spot and perp orders, vault transfers, staking and delegations, and more. Precompile reads go through `CoreView.sol`, so they return the simulatorâ€™s updated state.

Precompile calls are handled by `PrecompileSim.sol`, which is etched at each precompile address. When a precompile is called, its fallback forwards the read into `HyperCore` via the matching `CoreView` function. `CoreView` then does a conditional: if the value is already initialized in local state, it returns that; if not, it performs a live RPC read via `RealL1Read.sol` and returns the onchain value. 

CoreWriter actions are handled through `CoreWriterSim.sol`. It encodes all incoming CoreWriter calls into an ordered queue. When `CoreSimulatorLib.nextBlock()` is called to advance to the next block, it executes the queued actions in order by calling the relevant `execute*` functions on `HyperCore` and applies their state changes. Before applying each write, `CoreExecution` runs initializers (`initAccountWithToken`, `initAccount`, `initAccountWithPerp`) to initialise the required state by fetching current onchain values via `RealL1Read.sol` then the local state is updated, and subsequent precompile reads come from the stored state, not another RPC call. 

