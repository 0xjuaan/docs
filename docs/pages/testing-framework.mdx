---
title: Testing Framework
---

The testing framework simulates HyperCore interactions so you can test end-to-end flows:

- Full bridging flows between EVM and HyperCore
- Test CoreWriter actions
- Read updated precompile data after CoreWriter actions

### Why it's needed

Testing CoreWriter actions and their state changes is not possible today. This framework makes it possible by simulating HyperCore state. After a CoreWriter action, it updates precompile data so tests can read the new values right away. It also works with forked tests that start from the current state, the simulator updates the state from that point. 

### How to use it

Inherit `BaseSimulatorTest` in your tests. It handles basic setup, provides common token addresses and indices, and creates a `user` with $1,000 USDC in their Spot and Perp accounts on core.

CoreWriter actions only execute in the following blocks. Call the `CoreSimulatorLib.nextBlock()` function to move forward: it increases the block number and timestamp, executes all pending CoreWriter actions from the previous block and applies their state changes, then precompile reads will reflect the updated state.

### Acknowledgements

This work builds on the simulator by Cain from Hyperdrive. We adopted the core approach and added major changes, including forked testing to run against current chain state and support for Spot/Perp trading, among many others. See the original repo here: [hypercore-sim](https://github.com/ambitlabsxyz/hypercore/tree/main/packages/hypercore-sim).




## Example

```solidity
// Pseudocode
setUpHyperCoreHarness();

address usdc = deployTestToken(6);
address user = address(0xBEEF);

// Simulate bridging to Core
uint256 coreAmount = PrecompileLib.convertEvmToCoreAmount(usdc, 1_000_000);
CoreWriterLib.bridgeToCore(usdc, coreAmount, user);

// Validate Core state via precompiles
uint256 bal = PrecompileLib.spotBalanceByAddress(usdc, user);
assert(bal == coreAmount);
```

Refer to repository tests for full harness utilities and fixtures.

